/**************
 * Operations *
 **************/

operation register(pubkey, username: name){
  require( is_signer(pubkey) );
  require(not exists(user@?{.username == username}), "Username already exists");
  create user(pubkey, username);
}

operation look_for_game(user, nop: byte_array){
  require( is_signer(user.pubkey) );
  create user_looking_for_game(user, op_context.last_block_time);
}

operation stop_looking_for_game(user, nop: byte_array){
  require( is_signer(user.pubkey) );
  delete user_looking_for_game @? {user};
}

operation join_game(user, target_user:user, nop: byte_array){
  require( is_signer(user.pubkey) );
  require_not_empty(user_looking_for_game @? {target_user});
  delete user_looking_for_game @? {target_user};
  
  if ((user_looking_for_game @* {user} limit 1).size() > 1){
    delete user_looking_for_game @? {user};
  }
  val now = op_context.last_block_time;
  val game = create game(
    player_1 = target_user, 
    player_2 = user, 
    timestamp = now
  );
  
  create player_money(
    game,
    user = target_user
  );
  create player_money(
    game,
    user
  );
  
  create game_state(game);

  for (i in range(52)) {
    create deck_card(game, card_index = i);
  }
}

operation post_message (game, user, message: text, nop: byte_array) {
  require( is_signer(user.pubkey) );
  create message (game, user, message, op_context.last_block_time);
}

operation resign(game, user, nop: byte_array){
  require( is_signer(user.pubkey) );
  require(game.finished == -1);
  var winner = 0;
  if(user == game.player_1) winner = 2;
  if(user == game.player_2) winner = 1;
  update game(winner = winner, finished = op_context.last_block_time);
}

operation post_card_fragments(game, user, fragments: list<text>){
  require( is_signer(user.pubkey) );
  for(i in range(fragments.size())){
    create card_secret (
      game,
      user,
      card_index = i,
      fragment = fragments[i]
    );
  }
}

operation post_card_secret(game, user, card_index: integer, decrypt_key: text){
  require( is_signer(user.pubkey) );
  val card = card_secret@{game, user, card_index};
  update card(decrypt_key);
}

operation post_card_reveal(game, user, card_index: integer, reveal_value: text){
  require( is_signer(user.pubkey) );
  
  val card = deck_card@{game, card_index};
  if(card.reveal_value == "") update card(reveal_value);
  else if(card.reveal_value != reveal_value) update card(reveal_value = "skull");
}

operation pass_shuffled_deck (game, user, deck: list<text>) {
  require( is_signer(user.pubkey) );
  val game_state = require_not_empty(game_state @? {game});
  
  require(game_state.phrase < 0);
  if(game_state.phrase == -2 or game_state.phrase == -4) require(user == game.player_2);
  if(game_state.phrase == -1 or game_state.phrase == -3) require(user == game.player_1);
  
  for (i in range(52)) {
    val deck_card = deck_card@?{game, .card_index == i};
    update deck_card(encrypted = deck[i]);
  }
  update game_state(phrase = .phrase+1);
}

operation place_bet(game, user, round: integer, amount: integer){
  require( is_signer(user.pubkey) );
  create player_bet(game, user, round, amount);
  if(
    exists(player_bet@?{game, round, .user == game.player_1}) 
    and exists(player_bet@?{game, round, .user == game.player_2})
    ){
    val game_state = game_state@{game};
    deal_card_initial(game, round);
    update game_state(phrase = 1);
  }
}

function deal_card_initial(game, round:integer){
  create card_in_player_hand(
    game, 
    round,
    card_index = 0,
    player_index = 0,
    hand_index = 0,
    is_open = false
  );
  create card_in_player_hand(
    game, 
    round,
    card_index = 1,
    player_index = 1,
    hand_index = 0
  );
  create card_in_player_hand(
    game, 
    round,
    card_index = 2,
    player_index = 2,
    hand_index = 0
  );
  create card_in_player_hand(
    game, 
    round,
    card_index = 3,
    player_index = 0,
    hand_index = 1
  );
  create card_in_player_hand(
    game, 
    round,
    card_index = 4,
    player_index = 1,
    hand_index = 1
  );
  create card_in_player_hand(
    game, 
    round,
    card_index = 5,
    player_index = 2,
    hand_index = 1
  );
  
  update game_state@{game}(top_card_index = 6);
}

operation player_hit(game, user, nop: byte_array){
  require( is_signer(user.pubkey) );
  val game_state = game_state@{game};
  require((game.player_1 == user and game_state.phrase == 1) or (game.player_2 == user and game_state.phrase == 2));
  val round = game_state.round;
  val player_index = if(game.player_1 == user) 1 else 2;
  val cards_in_player_hand = card_in_player_hand@*{game, round, player_index}(card_index = .card_index);
  
  var value = 0;
  for(card in cards_in_player_hand){
    val card_name = deck_card@{game, .card_index == card.card_index}.reveal_value;
    value += value_from_card_name(card_name);
  }
  
  require(value < 21);
  
  create card_in_player_hand(
    game, 
    round,
    card_index = game_state.top_card_index,
    player_index,
    hand_index = cards_in_player_hand.size()
  );
  
  update game_state(top_card_index = .top_card_index + 1);
}

operation player_stand(game, user, nop: byte_array){
  require( is_signer(user.pubkey) );
  val game_state = game_state@{game};
  require((game.player_1 == user and game_state.phrase == 1) or (game.player_2 == user and game_state.phrase == 2));
  
  update game_state(phrase = .phrase + 1);
}