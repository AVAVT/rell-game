{"id":"271214240.93078583","name":"rell-blackjack","type":"Rell","code":[{"name":"chroma-chat.rell","text":"include 'utils';\ninclude 'classes';\ninclude 'operations';\ninclude 'queries';","props":{"isUpdated":false}},{"name":"classes.rell","text":"class user { \n  key pubkey; \n  key username: text; \n}\n\nclass game {\n  index player_1: user;\n  index player_2: user;\n  index timestamp;\n  mutable finished: timestamp = -1;\n  mutable winner: integer = -1;\n}\n\nclass message {\n  index game;\n  index author: user;\n  index timestamp;\n  message: text;\n}\n\nclass user_looking_for_game {\n  key user;\n  index timestamp;\n}\n\n/*\n phrase:\n -4 = player 2 shuffle\n -3 = player 1 shuffle\n -2 = player 2 lock\n -1 = player 1 lock\n 0 = dealing\n 1 = player 1 turn\n 2 = player 2 turn\n 3 = dealer turn\n*/\nclass game_state {\n  key game;\n  mutable top_card_index: integer = 0;\n  mutable phrase: integer = -4;\n  mutable round: integer = 1;\n}\n\nclass card_secret {\n  key game, user, card_index: integer;\n  fragment: text;\n  mutable decrypt_key: text = \"\";\n}\n\nclass deck_card {\n  key game, card_index: integer;\n  mutable encrypted: text = \"\";\n  mutable reveal_value: text = \"\";\n}\n\nclass card_in_player_hand {\n  key game, card_index: integer;\n  index round: integer;\n  index player_index: integer;\n  mutable is_open: boolean = true;\n}\n\nclass player_bet {\n  key game, user, round: integer;\n  amount: integer;\n}\n\nclass player_money {\n  key game, user;\n  mutable amount: integer = 100;\n}","props":{"isUpdated":false}},{"name":"operations.rell","text":"/**************\n * Operations *\n **************/\n\noperation register(pubkey, username: name){\n  require( is_signer(pubkey) );\n  require(not exists(user@?{.username == username}), \"Username already exists\");\n  create user(pubkey, username);\n}\n\noperation look_for_game(user, nop: byte_array){\n  require( is_signer(user.pubkey) );\n  create user_looking_for_game(user, op_context.last_block_time);\n}\n\noperation stop_looking_for_game(user, nop: byte_array){\n  require( is_signer(user.pubkey) );\n  delete user_looking_for_game @? {user};\n}\n\noperation join_game(user, target_user:user, nop: byte_array){\n  require( is_signer(user.pubkey) );\n  require_not_empty(user_looking_for_game @? {target_user});\n  delete user_looking_for_game @? {target_user};\n  \n  if ((user_looking_for_game @* {user} limit 1).size() > 1){\n    delete user_looking_for_game @? {user};\n  }\n  val now = op_context.last_block_time;\n  val game = create game(\n    player_1 = target_user, \n    player_2 = user, \n    timestamp = now\n  );\n  \n  create player_money(\n    game,\n    user = target_user\n  );\n  create player_money(\n    game,\n    user\n  );\n  \n  create game_state(game);\n\n  for (i in range(52)) {\n    create deck_card(game, card_index = i);\n  }\n}\n\noperation post_message (game, user, message: text, nop: byte_array) {\n  require( is_signer(user.pubkey) );\n  create message (game, user, message, op_context.last_block_time);\n}\n\noperation resign(game, user, nop: byte_array){\n  require( is_signer(user.pubkey) );\n  require(game.finished == -1);\n  var winner = 0;\n  if(user == game.player_1) winner = 2;\n  if(user == game.player_2) winner = 1;\n  update game(winner = winner, finished = op_context.last_block_time);\n}\n\noperation post_card_fragments(game, user, fragments: list<text>){\n  require( is_signer(user.pubkey) );\n  for(i in range(fragments.size())){\n    create card_secret (\n      game,\n      user,\n      card_index = i,\n      fragment = fragments[i]\n    );\n  }\n}\n\noperation post_card_secret(game, user, card_index: integer, decrypt_key: text){\n  require( is_signer(user.pubkey) );\n  val card = card_secret@{game, user, card_index};\n  update card(decrypt_key);\n}\n\noperation post_card_reveal(game, user, card_index: integer, reveal_value: text){\n  require( is_signer(user.pubkey) );\n  \n  val card = deck_card@{game, card_index};\n  \n  if(card.reveal_value != \"\" and card.reveal_value != reveal_value) update card(reveal_value = \"skull\");\n  else if(card.reveal_value == \"\"){\n    update card(reveal_value);\n    val game_state = game_state@{game};\n    if(game_state.phrase == 0){\n      if((player_bet@*{game, .round == game_state.round}).size() == 2){\n        var ready = true;\n        val all_cards = card_in_player_hand@*{game, .round == game_state.round};\n        for(card_in_hand in all_cards){\n          if(card_in_hand.is_open){\n            val card_in_deck = deck_card@{game, .card_index == card_in_hand.card_index};\n            if(card_in_deck.reveal_value == \"\" or card_in_deck.reveal_value == \"skull\") ready = false;\n          }\n        }\n      \n        if(ready) update game_state(phrase = 1);\n      }\n    }\n    else if (game_state.phrase == 3){\n      dealer_automated_action(game, game_state, game_state.round);\n    }\n    else if(game_state.phrase > 0){\n      val player_index = game_state.phrase;\n      val player_hand_value = calculate_player_hand_value(game, game_state.round, player_index);\n    \n      if(player_hand_value >= 21) {\n        update game_state(phrase = player_index + 1);\n        if(player_index == 2) {\n          update card_in_player_hand@{\n            game, \n            .round == game_state.round, \n            .is_open == false, \n            .player_index == 0\n          }( is_open = true );\n        }\n      }\n    }\n  }\n}\n\nfunction dealer_automated_action(game, game_state, round:integer){\n  val dealer_hand_value = calculate_player_hand_value(game, game_state.round, 0);\n  if(dealer_hand_value >= 17) {\n    end_of_round_scoring(game, game_state);\n  }\n  else{\n    val player_1_hand_value = calculate_player_hand_value(game, game_state.round, 1);\n    val player_2_hand_value = calculate_player_hand_value(game, game_state.round, 2);\n    if(player_1_hand_value > 21 and player_2_hand_value > 21){\n      end_of_round_scoring(game, game_state);\n    }\n    else{\n      deal_card_to_player(game, game_state, round, 0, true);\n    }\n  }\n}\n\nfunction end_of_round_scoring(game, game_state){\n  val dealer_hand_value = calculate_player_hand_value(game, game_state.round, 0);\n  for(player_index_0 in range(2)){\n    val user = if (player_index_0 == 0) game.player_1 else game.player_2;\n    val player_bet = player_bet @ {game, .round == game_state.round, user};\n    val player_money = player_money @ {game, user};\n    val player_hand_value = calculate_player_hand_value(game, game_state.round, player_index_0 + 1);\n    \n    update player_money(amount = .amount + player_bet.amount * calculate_player_winning(player_hand_value, dealer_hand_value));\n  }\n  \n  update game_state(phrase = 4);\n}\n\noperation ready_for_next_round(game, user, nop: byte_array){\n  require( is_signer(user.pubkey) );\n  val game_state = game_state@{game};\n  require(game_state.phrase > 3);\n  if(game_state.phrase == 4) update game_state(phrase = 5);\n  else if(game_state.phrase == 5) update game_state(round = .round + 1, phrase = 0);\n}\n\noperation pass_shuffled_deck (game, user, deck: list<text>) {\n  require( is_signer(user.pubkey) );\n  val game_state = require_not_empty(game_state @? {game});\n  \n  require(game_state.phrase < 0);\n  if(game_state.phrase == -2 or game_state.phrase == -4) require(user == game.player_2);\n  if(game_state.phrase == -1 or game_state.phrase == -3) require(user == game.player_1);\n  \n  for (i in range(52)) {\n    val deck_card = deck_card@?{game, .card_index == i};\n    update deck_card(encrypted = deck[i]);\n  }\n  update game_state(phrase = .phrase+1);\n}\n\noperation place_bet(game, user, round: integer, amount: integer){\n  require( is_signer(user.pubkey) );\n  val player_money = player_money@{game, user};\n  require(player_money.amount >= amount);\n  create player_bet(game, user, round, amount);\n  update player_money(amount = .amount - amount);\n  \n  if(\n    exists(player_bet@?{game, round, .user == game.player_1}) \n    and exists(player_bet@?{game, round, .user == game.player_2})\n    ){\n    val game_state = game_state@{game};\n    deal_card_initial(game, round);\n  }\n}\n\nfunction deal_card_initial(game, round:integer){\n  val game_state = game_state@{game};\n  if(game_state.top_card_index < 46){\n    for(hand_index in range(2)){\n      for(player_index in range(3)){\n        deal_card_to_player(game, game_state, round, player_index, hand_index != 0 or player_index != 0);\n      }\n    }\n  }\n}\n\noperation player_hit(game, user, nop: byte_array){\n  require( is_signer(user.pubkey) );\n  val game_state = game_state@{game};\n  require((game.player_1 == user and game_state.phrase == 1) or (game.player_2 == user and game_state.phrase == 2));\n  val round = game_state.round;\n  val player_index = if(game.player_1 == user) 1 else 2;\n  \n  var value = calculate_player_hand_value(game, round, player_index);\n  \n  require(value < 21);\n  \n  deal_card_to_player(game, game_state, round, player_index, true);\n}\n\nfunction deal_card_to_player(game, game_state, round: integer, player_index: integer, is_open: boolean){\n  if(game_state.top_card_index > 51){\n    end_of_round_scoring(game, game_state);\n  }\n  else{\n    create card_in_player_hand(\n      game, \n      round,\n      card_index = game_state.top_card_index,\n      player_index,\n      is_open\n    );\n  \n    update game_state(top_card_index = .top_card_index + 1);\n  }\n}\n\noperation player_stand(game, user, nop: byte_array){\n  require( is_signer(user.pubkey) );\n  val game_state = game_state@{game};\n  require((game.player_1 == user and game_state.phrase == 1) or (game.player_2 == user and game_state.phrase == 2));\n  if(game_state.phrase == 2){\n    update card_in_player_hand@{game, .round == game_state.round, .is_open == false, .player_index == 0}\n    (\n      is_open = true\n    );\n  }\n  update game_state(phrase = .phrase + 1);\n}","props":{"isUpdated":false}},{"name":"queries.rell","text":"/***********\n * Queries *\n ***********/\nquery ping() = \"pong\";\n\nquery get_user(user_pubkey: text){\n  val pubkey = byte_array(user_pubkey);\n  return user @? {pubkey} (.username, .pubkey, id=user);\n}\n\nquery get_wait_list(){\n  return user_looking_for_game@*{ } ( id = .user, username = .user.username, sort timestamp = .timestamp );\n}\n\nquery get_active_games(){\n  return game@*{.finished==-1}(id = game, player_1 =.player_1, player_1_name = .player_1.username, player_2 = .player_2, player_2_name = .player_2.username, sort timestamp = .timestamp);\n}\n\nquery get_lobby_status(){\n  val wait_list = user_looking_for_game@*{ } ( id = .user, username = .user.username, sort timestamp = .timestamp );\n  val game_list = game@*{.finished == -1}(id = game, player_1 =.player_1, player_1_name = .player_1.username, player_2 = .player_2, player_2_name = .player_2.username, sort timestamp = .timestamp);\n  return (wait_list = wait_list, game_list = game_list);\n}\n\nquery get_card_fragments(game){\n  var fragments = list<list<text>>();\n  \n  for(player_index in range(2)){\n    val player: user = if(player_index == 0) game.player_1 else game.player_2;\n    var player_secrets = card_secret@*{game, .user == player}(sort card_index = .card_index, fragment = .fragment);  \n    var player_fragments = list<text>();\n    for(secret in player_secrets){\n      player_fragments.add(secret.fragment);\n    }\n    fragments.add(player_fragments);\n  }\n  return fragments;\n}\n\n// TODO splits this into different queries depends on phase\nquery get_game_status(game){\n  val game_info = (id = game, player_1 = game.player_1, player_1_name = game.player_1.username, player_2 = game.player_2, player_2_name = game.player_2.username, finished=game.finished, winner = game.winner);\n  val messages = message@*{game}(author_name = .author.username, message = .message, sort timestamp = .timestamp);\n  val game_state = game_state@{game}(top_card_index = .top_card_index, phrase = .phrase, round = .round);\n  val deck = deck_card @* {game}(sort card_index = .card_index, encrypted = .encrypted, reveal_value = .reveal_value);\n  val player_monies = player_money @* {game}(id=.user, amount = .amount);\n  val player_bets = player_bet@*{game, .round == game_state.round}(id=.user, amount = .amount);\n  val hands_value = if(game_state.phrase > 3) [\n    calculate_player_hand_value(game, game_state.round, 0),\n    calculate_player_hand_value(game, game_state.round, 1),\n    calculate_player_hand_value(game, game_state.round, 2)\n  ] else [0,0,0];\n  var cards_in_player_hand = list<list<(card_index:integer, is_open: boolean)>>();\n  for(i in range(3)){\n    val cards = card_in_player_hand@*{game, .round == game_state.round, .player_index == i}(sort card_index = .card_index, is_open = .is_open);\n    cards_in_player_hand.add(cards);\n  }\n  \n  var card_decrypts = list<list<(card_index: integer, decrypt_key: text)>>();\n  card_decrypts.add(card_secret@*{game, .user == game.player_1}(sort card_index = .card_index, decrypt_key = .decrypt_key ));\n  card_decrypts.add(card_secret@*{game, .user == game.player_2}(sort card_index = .card_index, decrypt_key = .decrypt_key ));\n  \n  return (\n    game = game_info, \n    messages = messages, \n    game_state = game_state, \n    deck = deck, \n    player_monies = player_monies, \n    player_bets = player_bets,\n    cards_in_player_hand = cards_in_player_hand,\n    card_decrypts = card_decrypts,\n    hands_value = hands_value\n  );\n}\n","props":{"isUpdated":false}},{"name":"utils.rell","text":"function values_from_card_name(card_name: text) : list<integer>{\n  require(card_name != \"\");\n  \n  if(card_name.size() == 3) return [10];\n  if(card_name[0].compare_to(\"1\") == 0) return [1, 11];\n  for(i in range(8)){\n    val value = i + 2;\n    if(card_name[0].compare_to(value.to_text()) == 0) return [value];\n  }\n  return [10];\n}\n\nfunction calculate_player_hand_value(game, round: integer, player_index: integer): integer{\n  val cards_in_player_hand = card_in_player_hand@*{game, round, player_index};\n  \n  var values : list<integer> = [0];\n  for(card in cards_in_player_hand){\n    val card_name = deck_card@{game, .card_index == card.card_index}.reveal_value;\n    val card_values = values_from_card_name(card_name);\n    for(c in range(card_values.size())){\n      for(i in range(values.size())){\n        if(c > 0) values.add(values[i] + card_values[c]);\n        else values[i] = values[i] + card_values[c];\n      }\n    }\n  }\n  \n  val value = best_hand_value(values);\n  return value;\n}\n\nfunction best_hand_value(possible_values: list<integer>): integer{\n  require(possible_values.size() > 0);\n  \n  var u_21 = list<integer>();\n  var o_21 = list<integer>();\n  for(num in possible_values){\n    if(num > 21) o_21.add(num);\n    else u_21.add(num);\n  }\n  if(u_21.size() > 0){\n    u_21._sort();\n    return u_21[0];\n  }\n  else {\n    o_21._sort();\n    return o_21[o_21.size()-1];\n  }\n}\n\nfunction calculate_player_winning(player_hand_value : integer, dealer_hand_value : integer): integer{\n  if(player_hand_value > 21) return 0;\n  if(player_hand_value == dealer_hand_value) return 1;\n  if(player_hand_value == 21) return 3;\n  if(dealer_hand_value > 21 or dealer_hand_value < player_hand_value) return 2;\n  return 0;\n}","props":{"isUpdated":false}}],"tests":[{"name":"chroma-chat.tests","text":"","props":{"isUpdated":false}}]}