{"id":"271214240.93078583","name":"rell-blackjack","type":"Rell","code":[{"name":"chroma-chat.rell","text":"include 'utils';\ninclude 'classes';\ninclude 'operations';\ninclude 'queries';","props":{"isUpdated":false}},{"name":"classes.rell","text":"class user { \n  key pubkey; \n  key username: text; \n}\n\nclass game {\n  index player_1: user;\n  index player_2: user;\n  index timestamp;\n  mutable finished: timestamp = -1;\n  mutable winner: integer = -1;\n}\n\nclass message {\n  index game;\n  index author: user;\n  index timestamp;\n  message: text;\n}\n\nclass user_looking_for_game {\n  key user;\n  index timestamp;\n}\n\n/*\n phrase:\n -4 = player 2 shuffle\n -3 = player 1 shuffle\n -2 = player 2 lock\n -1 = player 1 lock\n 0 = dealing\n 1 = player 1 turn\n 2 = player 2 turn\n*/\nclass game_state {\n  key game;\n  mutable top_card_index: integer = 0;\n  mutable phrase: integer = -4;\n  mutable round: integer = 1;\n}\n\nclass card_secret {\n  key game, user, card_index: integer;\n  fragment: text;\n  mutable decrypt_key: text = \"\";\n}\n\nclass deck_card {\n  key game, card_index: integer;\n  mutable encrypted: text = \"\";\n  mutable reveal_value: text = \"\";\n}\n\nclass card_in_player_hand {\n  key game, card_index: integer;\n  index round: integer;\n  index player_index: integer;\n  hand_index: integer;\n  mutable is_open: boolean = true;\n}\n\nclass player_bet {\n  key game, user, round: integer;\n  amount: integer;\n}\n\nclass player_money {\n  key game, user;\n  mutable amount: integer = 100;\n}","props":{"isUpdated":false}},{"name":"operations.rell","text":"/**************\n * Operations *\n **************/\n\noperation register(pubkey, username: name){\n  require( is_signer(pubkey) );\n  require(not exists(user@?{.username == username}), \"Username already exists\");\n  create user(pubkey, username);\n}\n\noperation look_for_game(user, nop: byte_array){\n  require( is_signer(user.pubkey) );\n  create user_looking_for_game(user, op_context.last_block_time);\n}\n\noperation stop_looking_for_game(user, nop: byte_array){\n  require( is_signer(user.pubkey) );\n  delete user_looking_for_game @? {user};\n}\n\noperation join_game(user, target_user:user, nop: byte_array){\n  require( is_signer(user.pubkey) );\n  require_not_empty(user_looking_for_game @? {target_user});\n  delete user_looking_for_game @? {target_user};\n  \n  if ((user_looking_for_game @* {user} limit 1).size() > 1){\n    delete user_looking_for_game @? {user};\n  }\n  val now = op_context.last_block_time;\n  val game = create game(\n    player_1 = target_user, \n    player_2 = user, \n    timestamp = now\n  );\n  \n  create player_money(\n    game,\n    user = target_user\n  );\n  create player_money(\n    game,\n    user\n  );\n  \n  create game_state(game);\n\n  for (i in range(52)) {\n    create deck_card(game, card_index = i);\n  }\n}\n\noperation post_message (game, user, message: text, nop: byte_array) {\n  require( is_signer(user.pubkey) );\n  create message (game, user, message, op_context.last_block_time);\n}\n\noperation resign(game, user, nop: byte_array){\n  require( is_signer(user.pubkey) );\n  require(game.finished == -1);\n  var winner = 0;\n  if(user == game.player_1) winner = 2;\n  if(user == game.player_2) winner = 1;\n  update game(winner = winner, finished = op_context.last_block_time);\n}\n\noperation post_card_fragments(game, user, fragments: list<text>){\n  require( is_signer(user.pubkey) );\n  for(i in range(fragments.size())){\n    create card_secret (\n      game,\n      user,\n      card_index = i,\n      fragment = fragments[i]\n    );\n  }\n}\n\noperation post_card_secret(game, user, card_index: integer, decrypt_key: text){\n  require( is_signer(user.pubkey) );\n  val card = card_secret@{game, user, card_index};\n  update card(decrypt_key);\n}\n\noperation post_card_reveal(game, user, card_index: integer, reveal_value: text){\n  require( is_signer(user.pubkey) );\n  \n  val card = deck_card@{game, card_index};\n  if(card.reveal_value == \"\") update card(reveal_value);\n  else if(card.reveal_value != reveal_value) update card(reveal_value = \"skull\");\n}\n\noperation pass_shuffled_deck (game, user, deck: list<text>) {\n  require( is_signer(user.pubkey) );\n  val game_state = require_not_empty(game_state @? {game});\n  \n  require(game_state.phrase < 0);\n  if(game_state.phrase == -2 or game_state.phrase == -4) require(user == game.player_2);\n  if(game_state.phrase == -1 or game_state.phrase == -3) require(user == game.player_1);\n  \n  for (i in range(52)) {\n    val deck_card = deck_card@?{game, .card_index == i};\n    update deck_card(encrypted = deck[i]);\n  }\n  update game_state(phrase = .phrase+1);\n}\n\noperation place_bet(game, user, round: integer, amount: integer){\n  require( is_signer(user.pubkey) );\n  create player_bet(game, user, round, amount);\n  if(\n    exists(player_bet@?{game, round, .user == game.player_1}) \n    and exists(player_bet@?{game, round, .user == game.player_2})\n    ){\n    val game_state = game_state@{game};\n    deal_card_initial(game, round);\n    update game_state(phrase = 1);\n  }\n}\n\nfunction deal_card_initial(game, round:integer){\n  create card_in_player_hand(\n    game, \n    round,\n    card_index = 0,\n    player_index = 0,\n    hand_index = 0,\n    is_open = false\n  );\n  create card_in_player_hand(\n    game, \n    round,\n    card_index = 1,\n    player_index = 1,\n    hand_index = 0\n  );\n  create card_in_player_hand(\n    game, \n    round,\n    card_index = 2,\n    player_index = 2,\n    hand_index = 0\n  );\n  create card_in_player_hand(\n    game, \n    round,\n    card_index = 3,\n    player_index = 0,\n    hand_index = 1\n  );\n  create card_in_player_hand(\n    game, \n    round,\n    card_index = 4,\n    player_index = 1,\n    hand_index = 1\n  );\n  create card_in_player_hand(\n    game, \n    round,\n    card_index = 5,\n    player_index = 2,\n    hand_index = 1\n  );\n  \n  update game_state@{game}(top_card_index = 6);\n}\n\noperation player_hit(game, user, nop: byte_array){\n  require( is_signer(user.pubkey) );\n  val game_state = game_state@{game};\n  require((game.player_1 == user and game_state.phrase == 1) or (game.player_2 == user and game_state.phrase == 2));\n  val round = game_state.round;\n  val player_index = if(game.player_1 == user) 1 else 2;\n  \n  var value = calculate_player_hand_value(game, round, player_index);\n  \n  require(value < 21);\n  \n  create card_in_player_hand(\n    game, \n    round,\n    card_index = game_state.top_card_index,\n    player_index,\n    hand_index = cards_in_player_hand.size()\n  );\n  \n  update game_state(top_card_index = .top_card_index + 1);\n}\n\noperation player_stand(game, user, nop: byte_array){\n  require( is_signer(user.pubkey) );\n  val game_state = game_state@{game};\n  require((game.player_1 == user and game_state.phrase == 1) or (game.player_2 == user and game_state.phrase == 2));\n  \n  update game_state(phrase = .phrase + 1);\n}","props":{"isUpdated":false}},{"name":"queries.rell","text":"/***********\n * Queries *\n ***********/\nquery ping() = \"pong\";\n\nquery get_user(user_pubkey: text){\n  val pubkey = byte_array(user_pubkey);\n  return user @? {pubkey} (.username, .pubkey, id=user);\n}\n\nquery get_wait_list(){\n  return user_looking_for_game@*{ } ( id = .user, username = .user.username, sort timestamp = .timestamp );\n}\n\nquery get_active_games(){\n  return game@*{.finished==-1}(id = game, player_1 =.player_1, player_1_name = .player_1.username, player_2 = .player_2, player_2_name = .player_2.username, sort timestamp = .timestamp);\n}\n\nquery get_lobby_status(){\n  val wait_list = user_looking_for_game@*{ } ( id = .user, username = .user.username, sort timestamp = .timestamp );\n  val game_list = game@*{.finished == -1}(id = game, player_1 =.player_1, player_1_name = .player_1.username, player_2 = .player_2, player_2_name = .player_2.username, sort timestamp = .timestamp);\n  return (wait_list = wait_list, game_list = game_list);\n}\n\nquery get_card_fragments(game){\n  var fragments = list<list<text>>();\n  \n  for(player_index in range(2)){\n    val player: user = if(player_index == 0) game.player_1 else game.player_2;\n    var player_secrets = card_secret@*{game, .user == player}(sort card_index = .card_index, fragment = .fragment);  \n    var player_fragments = list<text>();\n    for(secret in player_secrets){\n      player_fragments.add(secret.fragment);\n    }\n    fragments.add(player_fragments);\n  }\n  return fragments;\n}\n\n// TODO splits this into different queries depends on phase\nquery get_game_status(game){\n  val game_info = (id = game, player_1 = game.player_1, player_1_name = game.player_1.username, player_2 = game.player_2, player_2_name = game.player_2.username, finished=game.finished, winner = game.winner);\n  val messages = message@*{game}(author_name = .author.username, message = .message, sort timestamp = .timestamp);\n  val game_state = game_state@{game}(top_card_index = .top_card_index, phrase = .phrase, round = .round);\n  val deck = deck_card @* {game}(sort card_index = .card_index, encrypted = .encrypted, reveal_value = .reveal_value);\n  val player_monies = player_money @* {game}(id=.user, amount = .amount);\n  val player_bets = player_bet@*{game, .round == game_state.round}(id=.user, amount = .amount);\n  \n  var cards_in_player_hand = list<list<(card_index:integer, is_open: boolean, hand_index:integer)>>();\n  for(i in range(3)){\n    val cards = card_in_player_hand@*{game, .round == game_state.round, .player_index == i}(card_index = .card_index, is_open = .is_open, sort hand_index = .hand_index);\n    cards_in_player_hand.add(cards);\n  }\n  \n  var card_decrypts = list<list<(card_index: integer, decrypt_key: text)>>();\n  card_decrypts.add(card_secret@*{game, .user == game.player_1}(sort card_index = .card_index, decrypt_key = .decrypt_key ));\n  card_decrypts.add(card_secret@*{game, .user == game.player_2}(sort card_index = .card_index, decrypt_key = .decrypt_key ));\n  \n  return (\n    game = game_info, \n    messages = messages, \n    game_state = game_state, \n    deck = deck, \n    player_monies = player_monies, \n    player_bets = player_bets,\n    cards_in_player_hand = cards_in_player_hand,\n    card_decrypts = card_decrypts\n  );\n}\n","props":{"isUpdated":false}},{"name":"utils.rell","text":"function values_from_card_name(card_name: text) : list<integer>{\n  require(card_name != \"\");\n  \n  if(card_name.size() == 3) return [10];\n  if(card_name[0].compare_to(\"1\") == 0) return [1, 11];\n  for(i in range(8)){\n    val value = i + 2;\n    if(card_name[0].compare_to(value.to_text()) == 0) return [value];\n  }\n  return [10];\n}\n\nfunction calculate_player_hand_value(game, round: integer, player_index: integer){\n  val cards_in_player_hand = card_in_player_hand@*{game, round, player_index}(card_index = .card_index);\n  \n  var values : list<integer> = [0];\n  for(card in cards_in_player_hand){\n    val card_name = deck_card@{game, .card_index == card.card_index}.reveal_value;\n    val card_values = values_from_card_name(card_name);\n    for(c in range(card_values.size())){\n      for(i in range(values.size())){\n        if(c > 0) values.add(values[i] + card_values[c]);\n        else values[i] = values[i] + card_values[c];\n      }\n    }\n  }\n  \n  val value = best_hand_value(values);\n  return value;\n}\n\nfunction best_hand_value(possible_values: list<integer>): integer{\n  require(possible_values.size() > 0);\n  \n  var u_21 = list<integer>();\n  var o_21 = list<integer>();\n  for(num in possible_values){\n    if(num > 21) o_21.add(num);\n    else u_21.add(num);\n  }\n  if(u_21.size() > 0){\n    u_21._sort();\n    return u_21[u_21.size()-1];\n  }\n  else {\n    o_21._sort();\n    return o_21[0];\n  }\n}","props":{"isUpdated":false}}],"tests":[{"name":"chroma-chat.tests","text":"","props":{"isUpdated":false}}]}