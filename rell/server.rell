class user { 
  key pubkey; 
  key username: text; 
}

class game {
  index player_1: user;
  index player_2: user;
  index timestamp;
  mutable finished: timestamp = -1;
  mutable winner: integer = -1;
}

class message {
  index game;
  index author: user;
  message: text;
  index timestamp;
}

class user_looking_for_game {
  key user;
  index timestamp;
}

/**************
 * Operations *
 **************/

operation register(pubkey, username: name){
  require( is_signer(pubkey) );
  require(not exists(user@?{.username == username}), "Username already exists");
  create user(pubkey, username);
}

operation look_for_game(user, nop: byte_array){
  require( is_signer(user.pubkey) );
  create user_looking_for_game(user, op_context.last_block_time);
}

operation stop_looking_for_game(user, nop: byte_array){
  require( is_signer(user.pubkey) );
  delete user_looking_for_game @? {user};
}

operation join_game(user, target_user:user, nop: byte_array){
  require( is_signer(user.pubkey) );
  require_not_empty(user_looking_for_game @? {target_user});
  delete user_looking_for_game @? {target_user};
  
  if ((user_looking_for_game @* {user} limit 1).size() > 1){
    delete user_looking_for_game @? {user};
  }
  val now = op_context.last_block_time;
  create game(
    player_1 = target_user, 
    player_2 = user, 
    timestamp = now
  );
}

operation post_message (game, user, message: text, nop: byte_array) {
  require( is_signer(user.pubkey) );
  create message (game, user, message, op_context.last_block_time);
}

operation resign(game, user, nop: byte_array){
  require( is_signer(user.pubkey) );
  require(game.finished == -1);
  var winner = 0;
  if(user == game.player_1) winner = 2;
  if(user == game.player_2) winner = 1;
  update game(winner = winner, finished = op_context.last_block_time);
}

/***********
 * Queries *
 ***********/
query ping() = "pong";

query get_user(user_pubkey: text){
  val pubkey = byte_array(user_pubkey);
  return user @? {pubkey} (.username, .pubkey, id=user);
}

query get_wait_list(){
  return user_looking_for_game@*{ } ( id = .user, username = .user.username, sort timestamp = .timestamp );
}

query get_active_games(){
  return game@*{.finished==-1}(id = game, player_1 =.player_1, player_1_name = .player_1.username, player_2 = .player_2, player_2_name = .player_2.username, sort timestamp = .timestamp);
}

query get_lobby_status(){
  val wait_list = user_looking_for_game@*{ } ( id = .user, username = .user.username, sort timestamp = .timestamp );
  val game_list = game@*{.finished==-1}(id = game, player_1 =.player_1, player_1_name = .player_1.username, player_2 = .player_2, player_2_name = .player_2.username, sort timestamp = .timestamp);
  return (wait_list = wait_list, game_list = game_list);
}

query get_game_status(game){
  val game_info = (player_1 = game.player_1, player_1_name = game.player_1.username, player_2 = game.player_2, player_2_name = game.player_2.username, finished=game.finished, winner = game.winner);
  val messages = message@*{game}(author_name = .author.username, message = .message, sort timestamp = .timestamp);
  return (game = game_info, messages = messages);
}
